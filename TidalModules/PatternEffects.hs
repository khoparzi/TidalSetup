-- From Kindohm
let erun = (run 8)
    srun = (run 16)
    delays = [(1/512), (1/256), (1/128), (1/64), (1/32), (1/16), (1/8)]
    spike p = ((# delaytime (range 0.001 0.3 $ slow 7.1 sine)) . (# delayfeedback (range 0.7 0.99 $ slow 6.71 sine))) $ p
    spike' p = (# delay "0.4") $ spike $ p
    shrand n = (n <~) $ rand
    shirand n p = (n <~) $ irand p
    replicator text1 = [putStr (text1) | x <- replicate 3000 text1]
    flood text2 = sequence_(replicator text2)
    rip feed timediv p = within (0.25, 0.75) (slow 2 . rev . stut 8 feed timediv) p
    rip' starttime endtime depth feed timediv p = within (starttime, endtime) (slow 2 . rev . stut depth feed timediv) p
    jit start amount p = within (start, (start + 0.5)) (trunc (amount)) p
    gtfo p = mute
    gtfo' p = (const $ midinote "~") p
    gtfom = gtfo'
    gtfo2 = gtfo'
    shift p = (1024 <~)  p
    shift' x p = (x <~) p
    one p = stut' 1 (0.125/2) (|*| gain "1") $ p
    one' p = rarely (stut' 1 (0.125/2) (|*| gain "1")) $ shift' 1024 $ p
    one'' p = sometimes (stut' 1 (0.125/2) (|*| gain "1")) $ shift' 1024 $ p
    rep depth p = stut' (depth - 1) (0.125*3) (|*| gain "1") $ p
    rep' depth p = stut' (depth - 1) (0.125/2*3) (|*| gain "1") $ p
    rep'' depth p = stut' (depth - 1) (0.125/4*3) (|*| gain "1") $ p
    randDelay p = ((# delay (range 0.5 0.7 $ shift' 5001 $ rand)) . (# delaytime (shift' 5002 $ choose delays)) . (# delayfeedback (range 0.5 0.9 $ shift' 5003 $ rand))) $ p
    rando = randDelay
    stupid = randDelay
    weird = randDelay
    beginend bpat durpat = (begin bpat) # (end $ (+) <$> bpat <*> durpat)
    inverse 1 = 0
    inverse 0 = 1
    inverse 11 = 0
    inverse 10 = 1
    move p = foldEvery [3,4] (0.25 <~) $ p
    move'' p = foldEvery [2,3] (0.25 <~) $ p
    move' p = foldEvery [3,4] (0.25 ~>) $ p
    move''' p = foldEvery [2,3] (0.25 ~>) $ p
    thicken' x percent p = superimpose ((# pan 1) . (|* speed percent)) $ ((# speed x) . (# pan 0)) $ p
    thicken p = thicken' 1 0.8 $ p
    fuckery p = every 5 (rip 0.5 0.1) $ every 6 (rip' 0 1 8 0.5 0.1) $ every 7 (# coarse "{4 8 6 12 16}%14") $ every 8 (# accelerate "-0.5 0.5") $ p
    discRange a b = (discretise 1 $ range a b $ shrand 10003)
    discrange = discRange
    triRange a b c = (range a b $ slow c tri)
    trirange = triRange
    cpsDisc a b = (|* cps (discRange a b))
    cpsRange a b c = (|* cps (triRange a b c))
    cpsTri = cpsRange --cps(a/120/2)
    bpmDisc a b = (|* cps ((discRange a b) / 60))
    bpmRange a b c = (|* cps ((triRange a b c) / 60))
    bpmTri = bpmRange

-- Pattern effects
let bo p = trunc (segment 8 $ slowsaw + 0.125) $ p
    ob = trunc (slow 4 $ "<0.25 0.5 0.75 1>")
    ob' d = trunc (slow d $ "<0.25 0.5 0.75 1>")
    dubd p = sometimes (stut (choose[4, 8]) 0.0125 (1/8)) $ p
    dubd' d p = sometimes (stut (choose[4, 8]) d (1/8)) $ p
    dubd'' d t p = sometimes (stut (choose[4, 8]) d t) $ p
    stbdub d p = sometimesBy d (stut (choose[4, 8]) (1/8) (1/8)) $ p
    stbdub' d t p = sometimesBy d (stut (choose[4, 8]) (1/8) t) $ p
    stbdub'' d t f p = sometimesBy d (stut (choose[4, 8]) f t) $ p
    crumble = slow 2 $ sound "[k*16 ~]/2 ~" # n (run 32)
    uppit p = spread fast [1, 2, 3, 4, 5, 7, 8] $ p
    ruppit p = spread fast [1, 2, 3, 4] $ p
    crippery p = every 4 (jux (# accelerate "[-0.1..0.2]/4")) $ every 6 (jux (# accelerate "[-0.3..0.4]/2")) $ p
    rater = rarely (iter (segment 1 $ choose [4,8]))
    withflip = within (0.5, 0.75) (fast 2)
    withflip' endPoint = within (0.5, endPoint) (fast 2)
    withply = within (0.5, 0.75) (ply 2)
    withply' endPoint = within (0.5, endPoint) (ply 2)
    someflip = sometimes (withflip)
    oftflip = often (withflip)
    rareflip = rarely (withflip)
    htrapper = within (0.5, 0.75) (hurry "1 <3 1.5>")
    ftrapper = within (0.5, 0.75) (fast "1 <3 1.5>")
    ftrapper' s r = within (s, s + r) (fast "<3 1.5>")
    htrapper' s r = within (s, s + r) (hurry "<3 1.5>")
    microd p = often ((# delay 0.3) . (# delaytime (choose[(1/16), (1/32)])) . (# delayfeedback 0.8)) $ p
    microd' p = rarely ((# delay 0.3) . (# delaytime (choose[(1/16), (1/32)])) . (# delayfeedback 0.8)) $ p
    microstb' a p = stb a ((# delay 0.3) . (# delaytime (choose[(1/16), (1/32)])) . (# delayfeedback 0.8)) $ p
    foldedParty p = foldEvery [3, 7, 13] (spread ($) [fast 4, jux (rev), spike]) $ p
    simplefuck p = foldEVery [5, 6, 7] (rip 0.5 "<0.1 0.2 0.4>") $ every 7 (# coarse "{4 8 6 12 16}%14") $ every 8 (# accelerate "-0.5 0.5") $ p
    mess = simplefuck
    simplefuck' p = foldEVery [5, 6, 7] (rip' 0 1 8 0.5 "<0.1 0.2 0.4>") $ every 7 (# coarse "{4 8 6 12 16}%14") $ every 8 (# accelerate "-0.5 0.5") $ p
    mess' = simplefuck'
    crushit p = (# crush (range 3 8 $ slow 1.1 tri)) $ p
    messup = fuckery
    messitup = fuckery
    funkSpread = spread ($)
    funkySpread = spreadChoose ($)
    restEvery m = every m (# silence)
